##### 高级Java

###### 1.架构的相关问题

###### 2.你对springcloud的了解？

springcloud是微服务架构系统的一站式解决方案，在构建微服务的过程中需要做服务注册和发现、配置中心、负载均衡、断路器、消息总线、数据监控等操作，springcloud提供的是一个简易的的编程模型，使我们可以在springboot的基础上轻松快速的完成完成微服务的构建。

###### 3.你所掌握的自动化测试工具

###### 4.微服务之间如何调用？

微服务调用通常有两种方式：一种是RPC方式，一种是事件驱动(Event-driven)方式。

RPC方式通常是通过springcloud的HTTP调用和dubbo的rpc远程服务调用来实现的；事件驱动则依赖于消息中间件和数据库。

###### 5.说说几种常见线程池及使用场景。

1）newCacheThreadPool

创建一个可以缓存的线程池，没有核心线程数，如果线程池的大小超过处理任务需要的线程，会回收部分空闲的线程池，不会对线程池大小做限制，阻塞队列是SynchronousQueue（单个元素的阻塞队列）。

使用场景：任务量大，耗时少。

2）newFixedThreadPool

创建一个固定数量的线程池，全是核心线程，也没有超时机制，阻塞队列是LinkedBlockingQueue（有链表结构组成的阻塞队列，最大值是Integer.MAX_VALUE）。

使用场景：任务量固定，耗时长。

3）newSingleThreadExecutor

创建一个单线程的线程池，阻塞队列是LinkedBlockingQueue（有链表结构组成的阻塞队列，最大值是Integer.MAX_VALUE）。

使用场景：按顺序执行的任务。

4）newScheduledThreadPool

创建一个固定数量可延迟执行的线程池，阻塞队列是DelayedWorkQueue（使用优先级队列实现的延迟无界阻塞队列）。

使用场景：定时任务和固定周期的重复任务。

> 一般不使用jdk自带线程池，因为这四种线程池要么不限制线程数，要么不限制阻塞队列大小，会造成OOM。

那么自己创建线程池的方法：new ThreadPoolExecutor。

1. corePoolSize：线程池中的常驻核心线程数。
2. maximumPoolSize：线程池能够同时执行的最大线程数，必须大于等于1。
3. keepAliveTime：多余的线程的存活时间。
4. unit：keepAliveTime的单位。
5. workQueue：任务队列，被提交但尚未执行的任务。（阻塞队列）
6. threadFactory：表示生成线程池的工作线程的线程工厂，用于创建线程，一般为默认线程工厂即可。
7. handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时，如何来拒绝来请求的Runnable的策略。

##### 中级Java

###### 1.你是如何理解和运用你所掌握的框架的？

###### 2.在开发时遇到过什么问题？怎么解决以及解决方案是什么？

###### 3.对分布式锁的实现方式的了解？

分布式锁的实现方式主要以（zookeeper、redis、MySQL）这三种为主。

1. 基于zookeeper有序节点：zookeeper允许临时创建有序的子节点，这样客户端获取节点列表时，就能够从当前子节点列表中的序号判断是否能够获得锁。
2. 基于redis的单线程：由于redis是单线程，所以命令会以串行的方式执行，并且本身提供了SETNX（set if not exists）这样的指令，本身具有互斥性。
3. 基于MySQL中的锁：MySQL本身有自带的悲观锁for update关键字，也可以自己实现悲观锁/乐观锁来达到目的。

###### 4.redis缓存原理与实现。

###### 5.微服务之间如何调用？

###### 6.说说几种常见线程池及使用场景。

###### 7.springmvc和struts2比较。

###### 8.关于MySQL优化。

###### 9.消息队列，kafka的了解。

###### 10.Oracle的大表处理，分区表

##### 初级Java

###### 1.你所掌握的技术具体要点是什么？

###### 2.关于MySQL优化，索引的各种问题？

###### 3.请你说一下区块链的相关内容。

###### 4.你这个项目的难点是什么？

###### 5.如何开展运维工作？

###### 6.如何看待加班？

###### 7.在以前的开发过程中有没有出现BUG，如果有，你是如何去解决的？从中学到了什么？

###### 8.关于MySQL的共享锁、排他锁、意向锁的相关问题。

MySQL锁机制分为表锁和行锁。其中行锁又包括了共享锁和排他锁。

**共享锁**又称读锁（S锁），当有多个事务时，多个事务对于同一数据可以共享一个锁，都能访问到数据，但是其他事务不能写数据。

**排他锁**又称写锁（X锁），当有多个事务时，排他锁不能与其他锁并存，一个事务获取了一行数据的排他锁，其他事务就不能获取该行事务的其他锁。获取了排他锁的事务才可以对数据进行读取和修改。

**意向锁**时innoDB所用的表锁，设计的主要目的为了一个事务中表示下一步需要请求的锁的类型。

有意向共享锁和意向排他锁，表示事务加入共享锁或者排他锁之前，需要获取意向锁。

###### 9.对数据库的掌握如何？

###### 10.描述项目经历？

###### 11.你认为在进行项目时需要注意的技术细节有哪些？

###### 12.IO和NIO的区别？

IO是面向字节流的阻塞型IO。NIO是面向缓冲区的非阻塞IO，Java NIO还有选择器允许一个单独的线程来监控多个通道。

###### 13.对String类有什么了解？

###### 14.你对数据库引擎有哪些了解？

MySQL数据库引擎有两个：innoDB和MyIASM。

1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
3. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
4. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；
5. 锁机制不同: InnoDB 为行级锁，myisam 为表级锁。

###### 15.你对sql优化有哪些了解？

sql优化是从三个方面去考虑：数据库设计、sql语句、读写分离与分库分表。

数据库设计：遵循数据库三范式（第一范式-列不可再分，第二范式-其他列依赖主键，第三范式-每列与主键直接相关）；字段尽量使用数值，属性尽量定长；建立合理索引。

sql语句：不要用*号，合理连接查询（会造成额外消耗，会使索引失效），合理使用索引。

读写分离与分库分表：主从模式（1、从库生成两个线程I/O和sql线程，IO线程去请求主库的binlog写到relay log。2、主库生成log dump线程用来给从库IO线程传binlog。3、SQL线程读取relay log，解析成具体操作。）；MySQL集群（mycat通过定义路由来实现分表，分片规则有时间、取模、hash等，根据sql语句和分片算法先去判断需要去操作哪个库或者全部库。）。

###### 16.你对数据库索引有哪些了解？

MySQL数据库的索引类型：

5. 普通索引（最基本的索引，没有限制）
2. 唯一索引（列必须唯一，允许为空）
3. 主键索引（列唯一，不为空）
4. 组合索引（多个字段创建的索引）
5. 全文索引（用来查找文本的关键字，fulltext索引配合match against来使用，而不是where）

以下情况索引会失效：

1. 条件中有or，则索引会失效。
2. 对于多列索引，不是使用的第一部分，则不会使用索引
3. like查询是以%开头
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

###### 17.二叉树和B+树有什么区别？

二叉树：二叉树可以提高查询效率，左小又大，但是无法掌握根节点的数字，容易一边倒，导致增多，查询效率下降。

红黑树：红黑树在二叉树基础之上，进行自平衡，自己来根据添加的数据来选定根节点是哪个，可以降低层数，提高查询效率.
但是红黑树一个节点只能存一个数。

b树：b树，一个节点可以搞多个树，又减少了层数

b+树：b+ 树，在b树的基础上进行再次优化，最多三层，前两层存的是索引，第三层叶子节点才是具体数据，查询效率最高。

###### 18.怎么保证消息队列多个服务不会重复消费或错误消费？

###### 19.分布式系统流程模块。

nginx -> vue（页面）-> gateway网关 -> 程序 -> MySQL、redis。

分布式事务：

2PC提交，**二阶段提交是一种强一致性设计**，2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。

2PC 是一种**尽量保证强一致性**的分布式事务，因此它是**同步阻塞**的，而同步阻塞就导致长久的资源锁定问题，**总体而言效率低**，并且存在**单点故障**问题，在极端条件下存在**数据不一致**的风险。

3PC提交，3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在**参与者中也引入了超时机制**，并且**新增了一个阶段**使得参与者可以利用这一个阶段统一各自的状态。3PC 包含了三个阶段，分别是**准备阶段、预提交阶段和提交阶段**，对应的英文就是：`CanCommit、PreCommit 和 DoCommit`。

###### 20.为什么数据库用了索引会快以及不用索引的好处？

为什么索引会快：无序数据变成了有序数据。

不用索引的情况：

1. 频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件 where条件里用不到的字段，不创建索引； 
2. 表记录太少，不需要创建索引；
3. 经常增删改的表； 
4. 数据重复且分布平均的字段，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引。